#include<stdio.h>
/*亲和数：考虑到1是每个整数的因子，把除去整数本身之外的所有因子叫做这个数的“真因子”。
如果两个整数，其中每一个真因子的和都恰好等于另一个数，那么这两个数，就构成一对亲和数。
最小的亲和数为：220和284
220的真因子是：1、2、4、5、10、11、20、22、44、55、110；
284的真因子是：1、2、4、71、142。
得284的真因子之和sum[284]=220，且220的真因子之和sum[220]=284，即有sum[220]=sum[sum[284]]=284。
*/
int sum[5000010];//防止越界
int main()
{
	int i,j;
	for(i = 0;i <= 5000000;i++)
	{
		sum[i] = 1;//1是所有数的真因数所以全部置1  
	}
	for(i = 2;i + 1 <= 5000000;i++)
	{
		//5000000以下最大的真因数是不超过它的一半的  
		//将所有i的倍数的位置上加i  
		j = i+i;
		while(j <= 5000000)
		{
			sum[j] += i;
			j += i;
		}
	}
	j = 1;
	// 一次遍历，因为知道最小是220和284因此从220开始  
	for(i = 220;i <= 5000000;i++)
	{
		//三个条件分别控制去重，不越界，满足亲和  
		if(sum[i] > i && sum[i] <= 5000000 && sum[sum[i]] == i)
		{
			printf("第%d对亲和数：%d,%d\n",j++,i,sum[i]);
		}
	}
	return 0;

	/*程序的构造与解释
    我再来具体解释下上述程序的原理，ok，举个例子，假设是求10以内的亲和数，求解步骤如下：

	因为所有数的真因数都包含1，所以，先在各个数的下方全部置1

	然后取i=2,3,4,5（i<=10/2），j依次对应的位置为j=（4、6、8、10），（6、9）,（8）,（10）各数所对应的位置。
	依据j所找到的位置，在j所指的各个数的下面加上各个真因子i（i=2、3、4、5）。
	整个过程，即如下图所示（如sum[6]=1+2+3=6，sum[10]=1+2+5=8.）：
	1  2  3  4  5  6  7  8  9  10
	1  1  1  1  1  1  1  1  1   1
			 2     2     2      2
				   3        3 
						 4
								5
	然后一次遍历i从220开始到5000000，i每遍历一个数后，
	将i对应的数下面的各个真因子加起来得到一个和sum[i]，如果这个和sum[i]==某个i’，且sum[i‘]=i，
	那么这两个数i和i’，即为一对亲和数。
	i=2；sum[4]+=2，sum[6]+=2，sum[8]+=2，sum[10]+=2，sum[12]+=2...
	i=3，sum[6]+=3，sum[9]+=3...
	......
	i=220时，sum[220]=284，i=284时，sum[284]=220；即sum[220]=sum[sum[284]]=284，
	得出220与284是一对亲和数。所以，最终输出220、284，...
	*/
}